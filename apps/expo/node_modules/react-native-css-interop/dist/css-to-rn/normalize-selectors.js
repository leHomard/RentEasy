"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toRNProperty = exports.normalizeSelectors = void 0;
function normalizeSelectors(extractedStyle, selectorList, options, selectors = [], defaults = {}) {
    for (let cssSelector of selectorList) {
        if (isIsPseudoClass(cssSelector)) {
            normalizeSelectors(extractedStyle, cssSelector[0].selectors, options, selectors);
            continue;
        }
        if (isRootVariableSelector(cssSelector)) {
            if (isDarkModeMediaQuery(extractedStyle.media?.[0])) {
                selectors.push({
                    type: "rootVariables",
                    subtype: "dark",
                });
            }
            else {
                selectors.push({
                    type: "rootVariables",
                    subtype: "light",
                });
            }
            continue;
        }
        if (isRootDarkVariableSelector(cssSelector, options)) {
            selectors.push({
                type: "rootVariables",
                subtype: "dark",
            });
            continue;
        }
        if (isDefaultVariableSelector(cssSelector)) {
            if (isDarkModeMediaQuery(extractedStyle.media?.[0])) {
                selectors.push({
                    type: "universalVariables",
                    subtype: "dark",
                });
            }
            else {
                selectors.push({
                    type: "universalVariables",
                    subtype: "light",
                });
            }
            continue;
        }
        if (isDarkDefaultVariableSelector(cssSelector, options)) {
            selectors.push({
                type: "universalVariables",
                subtype: "dark",
            });
            continue;
        }
        if (isDarkClassSelector(cssSelector, options)) {
            const [_, __, third, ...rest] = cssSelector;
            normalizeSelectors(extractedStyle, [[third, ...rest]], options, selectors, {
                media: [
                    {
                        mediaType: "all",
                        condition: {
                            type: "feature",
                            value: {
                                type: "plain",
                                name: "prefers-color-scheme",
                                value: { type: "ident", value: "dark" },
                            },
                        },
                    },
                ],
            });
            continue;
        }
        let isValid = true;
        let previousType = "combinator";
        let inGroup = false;
        const selector = {
            ...defaults,
            type: "className",
            className: "",
            specificity: {},
        };
        for (const component of cssSelector) {
            if (!isValid) {
                break;
            }
            switch (component.type) {
                case "universal":
                case "namespace":
                case "nesting":
                case "id":
                case "pseudo-element":
                    isValid = false;
                    break;
                case "attribute": {
                    if (!selector.groupClassName && !selector.className) {
                        if (component.name === "dir" &&
                            component.operation?.operator === "equal") {
                            selector.media ??= [];
                            selector.media.push({
                                mediaType: "all",
                                condition: {
                                    type: "feature",
                                    value: {
                                        type: "boolean",
                                        name: component.operation.value,
                                    },
                                },
                            });
                        }
                        else {
                            isValid = false;
                        }
                        break;
                    }
                    selector.specificity.B ??= 0;
                    selector.specificity.B++;
                    let attrs;
                    if (inGroup) {
                        selector.groupAttrs ??= [];
                        attrs = selector.groupAttrs;
                    }
                    else {
                        selector.attrs ??= [];
                        attrs = selector.attrs;
                    }
                    if (component.name.startsWith("data-")) {
                        attrs.push({
                            ...component,
                            name: toRNProperty(component.name.replace("data-", "")),
                            type: "data-attribute",
                        });
                    }
                    else {
                        attrs.push(component);
                    }
                    break;
                }
                case "type": {
                    selector.specificity.C ??= 0;
                    selector.specificity.C++;
                    isValid = component.name === options.selectorPrefix;
                    break;
                }
                case "combinator": {
                    if (component.value !== "descendant") {
                        isValid = false;
                    }
                    inGroup = false;
                    break;
                }
                case "class": {
                    selector.specificity.B ??= 0;
                    selector.specificity.B++;
                    switch (previousType) {
                        case "combinator": {
                            if (selector.className) {
                                isValid = false;
                            }
                            else if (component.name === options.selectorPrefix?.slice(1)) {
                                break;
                            }
                            else {
                                const groupingValid = !selector.groupClassName &&
                                    options.grouping.some((group) => {
                                        return group.test(component.name);
                                    });
                                if (groupingValid) {
                                    selector.groupClassName = component.name;
                                    selector.groupPseudoClasses = selector.pseudoClasses;
                                    selector.pseudoClasses = {};
                                    inGroup = true;
                                }
                                else if (!selector.className) {
                                    selector.className = component.name;
                                }
                                else {
                                    isValid = false;
                                }
                            }
                            break;
                        }
                        case "class": {
                            if (!inGroup) {
                                isValid = false;
                                break;
                            }
                            selector.groupAttrs ??= [];
                            selector.groupAttrs.push({
                                type: "attribute",
                                name: "className",
                                operation: { operator: "includes", value: component.name },
                            });
                            break;
                        }
                        default: {
                            isValid = false;
                        }
                    }
                    break;
                }
                case "pseudo-class": {
                    selector.specificity.B ??= 0;
                    selector.specificity.B++;
                    let pseudoClasses;
                    let attrs;
                    switch (previousType) {
                        case "pseudo-class":
                        case "class": {
                            if (selector.className) {
                                selector.pseudoClasses ??= {};
                                pseudoClasses = selector.pseudoClasses;
                                selector.attrs ??= [];
                                attrs = selector.attrs;
                            }
                            else if (selector.groupClassName) {
                                selector.groupPseudoClasses ??= {};
                                pseudoClasses = selector.groupPseudoClasses;
                                selector.groupAttrs ??= [];
                                attrs = selector.groupAttrs;
                            }
                            else {
                                isValid = false;
                            }
                            break;
                        }
                        default: {
                            isValid = false;
                        }
                    }
                    if (!isValid) {
                        break;
                    }
                    switch (component.kind) {
                        case "hover":
                        case "active":
                        case "focus":
                            pseudoClasses ??= {};
                            pseudoClasses[component.kind] = true;
                            break;
                        case "disabled":
                            attrs ??= [];
                            attrs.push({
                                type: "attribute",
                                name: "disabled",
                                operation: { operator: "truthy" },
                            });
                            break;
                        case "empty":
                            attrs ??= [];
                            attrs.push({
                                type: "attribute",
                                name: "children",
                                operation: { operator: "empty" },
                            });
                            break;
                    }
                }
            }
            previousType = component.type;
        }
        if (!selector.className) {
            isValid = false;
        }
        if (!isValid) {
            continue;
        }
        selectors.push(selector);
    }
    return selectors;
}
exports.normalizeSelectors = normalizeSelectors;
function isIsPseudoClass(selector) {
    return (selector.length === 1 &&
        selector[0].type === "pseudo-class" &&
        selector[0].kind === "is");
}
function isDarkModeMediaQuery(query) {
    return Boolean(query?.condition &&
        query.condition.type === "feature" &&
        query.condition.value.type === "plain" &&
        query.condition.value.name === "prefers-color-scheme" &&
        query.condition.value.value.value === "dark");
}
function isDarkClassSelector([first, second, third], options) {
    return (options.darkMode?.type === "class" &&
        first &&
        second &&
        third &&
        first.type === "class" &&
        first.name === options.darkMode?.value &&
        second.type === "combinator" &&
        second.value === "descendant" &&
        third.type === "class");
}
function isRootVariableSelector([first, second]) {
    return (first && !second && first.type === "pseudo-class" && first.kind === "root");
}
function isDefaultVariableSelector([first, second]) {
    return first && !second && first.type === "universal";
}
function isRootDarkVariableSelector([first, second], options) {
    return (options.darkMode?.type === "class" &&
        first.type === "class" &&
        first.name === options.darkMode.value &&
        second &&
        second.type === "pseudo-class" &&
        second.kind === "root");
}
function isDarkDefaultVariableSelector([first, second, third], options) {
    return (options.darkMode?.type === "class" &&
        first &&
        second &&
        third &&
        first.type === "class" &&
        first.name === options.darkMode.value &&
        second.type === "combinator" &&
        second.value === "descendant" &&
        third.type === "universal");
}
function toRNProperty(str) {
    return str.replace(/^-rn-/, "").replace(/-./g, (x) => x[1].toUpperCase());
}
exports.toRNProperty = toRNProperty;
//# sourceMappingURL=normalize-selectors.js.map